/**
 * Copyright 2011,2012 National ICT Australia Limited
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.nicta.scoobi.examples

// test.Weather is a class that has been generated by sbt-avro
// based on the schema at: src/main/avro/weather.avsc

import org.apache.avro.specific.SpecificRecordBase
import org.apache.hadoop.io.serializer.avro.AvroRecord

// make sure to run "sbt avro:generate" to generate the sources in:
// target/scala-2.x/src_managed/main/compiled_avro
import test.AvroWeather
import com.nicta.scoobi.Scoobi._


object AvroExample extends ScoobiApp {

  def run() {

    // There are WireFormat's for avro records, so there's no problem in creating DLists of them

    val weatherList: DList[AvroWeather] = DList(
      new AvroWeather("Town Hall", 925, 23),
      new AvroWeather("Red Fern", 1201, -55),
      new AvroWeather("Bondi Junction", 1920, 100))

    // and they can easily be persisted, using our schema ( at src/main/avro/weather.avsc )
    weatherList.toAvroFile("output-avro", overwrite=true).persist

    // and of course, it's easy to read avro files to disk, given a schema!
    val weatherReadList: DList[AvroWeather] = fromAvroFile[AvroWeather]("output-avro")

    weatherReadList.toTextFile("output-text", overwrite=true).persist

    // The other plugin we are using, generates AvroSchema's for case-classes, as we have to do
    // is extend AvroRecord, and make sure all the members are 'var's
    case class Person(var name: String, var awesomeness: Int)
      //extends AvroRecord
    /* if you extend AvroRecord, you'll get:
    [error] .../scoobi/examples/avro/src/main/scala/AvroExample.scala:60: ambiguous implicit values:
    [error]  both value personFmt of type com.nicta.scoobi.core.WireFormat[Person]
      [error]  and method AvroFmt in trait LowPriorityWireFormatImplicits of type [T <: org.apache.avro.specific.SpecificRecordBase](implicit evidence$4: Manifest[T], implicit evidence$5: com.nicta.scoobi.io.avro.AvroSchema[T])com.nicta.scoobi.Scoobi.AvroWireFormat[T]
      [error]  match expected type com.nicta.scoobi.core.WireFormat[Person]
      [error]     val joined: DList[(Person, AvroWeather)] = DObject(p) join weatherReadList
      [error]                                                       ^
    [error] one error found
      [error] (compile:compile) Compilation failed
    */

    // without "extends AvroRecord, you'd need to uncomment the line below:
    implicit val personFmt = mkCaseWireFormat(Person, Person.unapply _)

    val p = new Person("Eric", 10)

    // There are also WireFormat's available, so there's no problem doing all the cool stuff
    // that scoobi allows. e.g.
    val joined: DList[(Person, AvroWeather)] = DObject(p) join weatherReadList

    // and let's dump it to a text file, so you can easily verify it worked ;D
    joined.toTextFile("output-joined", overwrite=true).persist

    // Output of output-joined/out-m-00000 should look like:
    //(Person(Eric,10),{"station": "Town Hall", "time": 925, "temp": 23})
    //(Person(Eric,10),{"station": "Red Fern", "time": 1201, "temp": -55})
    //(Person(Eric,10),{"station": "Bondi Junction", "time": 1920, "temp": 100})
  }
}
